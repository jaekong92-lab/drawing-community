<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ì˜¨ë¼ì¸ ê·¸ë¦¼íŒ (Online Drawing Tool)</title>
<style>
/* ìº”ë²„ìŠ¤ ì»¨íŠ¸ë¡¤ ì˜ì—­ ìŠ¤íƒ€ì¼ë§ (ì„ íƒ ì‚¬í•­) */
.controls {
Â  Â  margin-bottom: 10px;
Â  Â  padding: 10px;
Â  Â  border: 1px solid #ccc;
Â  Â  background-color: #f9f9f9;
Â  Â  border-radius: 5px;
Â  Â  display: inline-block;
}
.tool-button {
Â  Â  cursor: pointer;
Â  Â  padding: 5px 10px;
Â  Â  border: 1px solid #ddd;
Â  Â  background-color: #fff;
Â  Â  margin-right: 5px;
Â  Â  border-radius: 3px;
}
/* 'active' í´ë˜ìŠ¤ë¥¼ íˆ´ ì„ íƒ ì‹œ ì ìš© */
.tool-button.active {
Â  Â  background-color: #a4c8f5;
Â  Â  color: white;
Â  Â  border-color: #5b9bf8;
}
</style>
</head>
<body onload="init()">
<h3>ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­ ê·¸ë¦¬ê¸° (ê¸°ë³¸ íœ), ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ì§€ìš°ê¸°, Ctrl + ì¢Œí´ë¦­ìœ¼ë¡œ ì§ì„  ê·¸ë¦¬ê¸°, Ctrl + ìš°í´ë¦­ìœ¼ë¡œ ì „ë¶€ ì§€ìš°ê¸° </h3>
<p>
Â  Â  <strong>Shift + &lt; (ì‰¼í‘œ)</strong>: ì‹¤í–‰ ì·¨ì†Œ (Undo) |Â 
Â  Â  <strong>Shift + &gt; (ë§ˆì¹¨í‘œ)</strong>: ë‹¤ì‹œ ì‹¤í–‰ (Redo) |
Â  Â  <strong>Shift + ë“œë˜ê·¸</strong>: ì •ê·œ ë„í˜• ê·¸ë¦¬ê¸° (ì •ì‚¬ê°í˜•, ì •ì‚¼ê°í˜•, ì •ì›)
</p>
<hr>

<div class="controls">
Â  Â  <label for="colorPicker">ğŸ¨ ê·¸ë¦¬ê¸° ìƒ‰ìƒ: </label>
Â  Â  <input type="color" id="colorPicker" value="#000000">Â 
Â  Â  &nbsp;&nbsp;&nbsp;
Â  Â  <label for="penLineWidthRange">íœ êµµê¸°: </label>
Â  Â  <input type="range" id="penLineWidthRange" min="1" max="50" value="2">
Â  Â  <span id="currentPenLineWidth">2</span>px
Â  Â  &nbsp;&nbsp;&nbsp;
Â  Â  <label for="eraseLineWidthRange">ì§€ìš°ê°œ êµµê¸°: </label>
Â  Â  <input type="range" id="eraseLineWidthRange" min="1" max="100" value="20">
Â  Â  <span id="currentEraseLineWidth">20</span>px
</div>

<div class="controls">
Â  Â  <button class="tool-button active" id="toolPencil" onclick="setTool('pencil')">âœï¸ íœ</button>
Â  Â  <button class="tool-button" id="toolFill" onclick="setTool('fill')"> bucket ì±„ìš°ê¸°</button>
Â  Â  <button class="tool-button" id="toolEyedropper" onclick="setTool('eyedropper')">ğŸ’‰ ìŠ¤í¬ì´ë“œ</button>
Â  Â  <button class="tool-button" id="toolRectangle" onclick="setTool('rectangle')">ğŸŸ¦ ì‚¬ê°í˜•</button>
Â  Â  <button class="tool-button" id="toolCircle" onclick="setTool('circle')">â­• ì›</button>
Â  Â  <button class="tool-button" id="toolTriangle" onclick="setTool('triangle')">ğŸ”º ì‚¼ê°í˜•</button>
Â  Â  &nbsp;&nbsp;&nbsp;
    <button onclick="downloadCanvas()">ğŸ–¼ï¸ ê·¸ë¦¼ ì €ì¥ (PNG)</button>
    &nbsp;&nbsp;&nbsp;
    <button onclick="uploadCanvas()">ğŸ“¢ ê·¸ë¦¼ ê³µìœ í•˜ê¸°</button>
</div>
<br>

<canvas id="myCanvas" style="background-color:aliceblue; border: 1px solid #ccc;" width="2100" height="800"></canvas>

<script>
let canvas, context;
const DEFAULT_PEN_LINE_WIDTH = 2;Â 
const DEFAULT_ERASE_LINE_WIDTH = 20;Â 
const BACKGROUND_COLOR = "aliceblue";Â 
const ERASE_COLOR = BACKGROUND_COLOR;Â  // ì§€ìš°ê°œëŠ” ë°°ê²½ìƒ‰ìœ¼ë¡œ ë®ì–´ì“°ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

let startX = 0, startY = 0;Â 
let drawing = false;Â 
let isErasing = false;Â 

// íˆ´ ê´€ë ¨ ë³€ìˆ˜
let currentTool = 'pencil';Â 
let isDrawingShape = false;Â 
let isShiftPressed = false;Â 

// êµµê¸° ê´€ë ¨ DOM ë³€ìˆ˜
let penLineWidthRange, eraseLineWidthRange, currentPenLineWidthSpan, currentEraseLineWidthSpan;

// === Undo/Redo ê´€ë ¨ ë³€ìˆ˜ ===
let history = [];Â 
let historyPointer = -1;Â 
const MAX_HISTORY_SIZE = 30;Â 


// === [ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜] ===
function rgbToHex(r, g, b) {
Â  Â  // 0~255 ê°’ì„ 16ì§„ìˆ˜ ë‘ ìë¦¬ ë¬¸ìì—´ë¡œ ë³€í™˜
Â  Â  if (r > 255 || g > 255 || b > 255) return "000000";
Â  Â  return ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
}


/**
Â * í˜„ì¬ ìƒíƒœ(isErasing)ì— ë”°ë¼ contextì˜ ìƒ‰ìƒê³¼ êµµê¸°ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
Â */
function updateContextStyles() {
Â  Â  if (isErasing) {
Â  Â  Â  Â  context.strokeStyle = ERASE_COLOR;
Â  Â  Â  Â  context.fillStyle = ERASE_COLOR;
Â  Â  Â  Â  context.lineWidth = eraseLineWidthRange.value;
Â  Â  Â  Â  context.globalCompositeOperation = 'source-over'; // ì¼ë°˜ ë®ì–´ì“°ê¸° ëª¨ë“œ
Â  Â  } else {
Â  Â  Â  Â  context.strokeStyle = document.getElementById("colorPicker").value;
Â  Â  Â  Â  context.fillStyle = document.getElementById("colorPicker").value;
Â  Â  Â  Â  context.lineWidth = penLineWidthRange.value;
Â  Â  Â  Â  context.globalCompositeOperation = 'source-over'; // ì¼ë°˜ ê·¸ë¦¬ê¸° ëª¨ë“œ
Â  Â  }
}

function init() {
Â  Â  canvas = document.getElementById("myCanvas");
Â  Â  context = canvas.getContext("2d");
Â  Â Â 
Â  Â  // ì»¨íŠ¸ë¡¤ ìš”ì†Œ DOM ê°ì²´ ê°€ì ¸ì˜¤ê¸°
Â  Â  let colorPicker = document.getElementById("colorPicker");
Â  Â Â 
Â  Â  penLineWidthRange = document.getElementById("penLineWidthRange");
Â  Â  eraseLineWidthRange = document.getElementById("eraseLineWidthRange");
Â  Â  currentPenLineWidthSpan = document.getElementById("currentPenLineWidth");
Â  Â  currentEraseLineWidthSpan = document.getElementById("currentEraseLineWidth");

Â  Â  context.fillStyle = BACKGROUND_COLOR;
Â  Â  context.fillRect(0, 0, canvas.width, canvas.height);

Â  Â  // ì´ˆê¸° ìŠ¤íƒ€ì¼ ì„¤ì •
Â  Â  updateContextStyles();Â 
Â  Â Â 
Â  Â  context.lineCap = 'round';
Â  Â  context.lineJoin = 'round';
Â  Â Â 
Â  Â  // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
Â  Â  canvas.addEventListener("mousemove", move, false);
Â  Â  canvas.addEventListener("mousedown", down, false);
Â  Â  canvas.addEventListener("mouseup", up, false);
Â  Â  canvas.addEventListener("mouseout", out, false);
Â  Â Â 
Â  Â  canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);
Â  Â Â 
Â  Â  document.addEventListener("keydown", handleKeydown, false);
Â  Â  document.addEventListener("keyup", handleKeyup, false);Â 

Â  Â  // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
Â  Â  colorPicker.addEventListener("input", updateContextStyles);

Â  Â  penLineWidthRange.addEventListener("input", function() {
Â  Â  Â  Â  currentPenLineWidthSpan.textContent = this.value;
Â  Â  Â  Â  if (!isErasing) updateContextStyles();
Â  Â  });

Â  Â  eraseLineWidthRange.addEventListener("input", function() {
Â  Â  Â  Â  currentEraseLineWidthSpan.textContent = this.value;
Â  Â  Â  Â  if (isErasing) updateContextStyles();
Â  Â  });
Â  Â Â 
Â  Â  saveState();Â 
}

function setTool(toolName) {
Â  Â  currentTool = toolName;
Â  Â  document.querySelectorAll('.tool-button').forEach(btn => {
Â  Â  Â  Â  btn.classList.remove('active');
Â  Â  });
Â  Â  
Â  Â  // íˆ´ ë²„íŠ¼ì— active í´ë˜ìŠ¤ ì„¤ì •
Â  Â  let btn;
Â  Â  if (toolName === 'fill') {
Â  Â  Â  Â  btn = document.getElementById('toolFill');
Â  Â  } else if (toolName === 'eyedropper') { // â­ ìŠ¤í¬ì´ë“œ íˆ´ ID ì²˜ë¦¬
Â  Â  Â  Â  btn = document.getElementById('toolEyedropper');
Â  Â  } else {
Â  Â  Â  Â  btn = document.getElementById('tool' + toolName.charAt(0).toUpperCase() + toolName.slice(1));
Â  Â  }
Â  Â Â 
Â  Â  if(btn) btn.classList.add('active');
Â  Â Â 
Â  Â  drawing = false;
Â  Â  isErasing = false;
Â  Â Â 
Â  Â  // íˆ´ ë³€ê²½ ì‹œ íœì˜ ìƒ‰ìƒê³¼ êµµê¸°ë¡œ context ì„¤ì • ë³µì›
Â  Â  updateContextStyles();
}


// === [Undo/Redo ë° ìƒíƒœ ê´€ë¦¬ í•¨ìˆ˜] ===

function saveState() {
Â  Â  if (historyPointer < history.length - 1) {
Â  Â  Â  Â  history = history.slice(0, historyPointer + 1);
Â  Â  }
Â  Â Â 
Â  Â  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
Â  Â Â 
Â  Â  const dataCopy = {
Â  Â  Â  Â  width: imageData.width,
Â  Â  Â  Â  height: imageData.height,
Â  Â  Â  Â  data: new Uint8ClampedArray(imageData.data)
Â  Â  };

Â  Â  history.push(dataCopy);
Â  Â  historyPointer++;
Â  Â  if (history.length > MAX_HISTORY_SIZE) {
Â  Â  Â  Â  history.shift();
Â  Â  Â  Â  historyPointer--;
Â  Â  }
}

function restoreState() {
Â  Â  if (historyPointer >= 0 && historyPointer < history.length) {
Â  Â  Â  Â  const dataCopy = history[historyPointer];
Â  Â  Â  Â Â 
Â  Â  Â  Â  const imageData = new ImageData(dataCopy.data, dataCopy.width, dataCopy.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  context.clearRect(0, 0, canvas.width, canvas.height);Â 
Â  Â  Â  Â  context.putImageData(imageData, 0, 0);Â 

Â  Â  Â  Â  // contextì˜ ì„¤ì •ê°’ ë³µì› (íœ êµµê¸°ë¡œ ë³µì›)
Â  Â  Â  Â  updateContextStyles();
Â  Â  }
}

function restoreFromTempState() {
Â  Â  if (historyPointer >= 0) {
Â  Â  Â  Â  restoreState();Â 
Â  Â  } else {
Â  Â  Â  Â  context.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  context.fillStyle = BACKGROUND_COLOR;
Â  Â  Â  Â  context.fillRect(0, 0, canvas.width, canvas.height);
Â  Â  }
}


function handleKeydown(e) {
Â  Â  if (e.key === 'Shift') {
Â  Â  Â  Â  isShiftPressed = true;
Â  Â  }
Â  Â Â 
Â  Â  if (e.shiftKey && e.keyCode === 188) { // Shift + < (Undo)
Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  if (historyPointer > 0) {
Â  Â  Â  Â  Â  Â  historyPointer--;
Â  Â  Â  Â  Â  Â  restoreState();
Â  Â  Â  Â  }
Â  Â  }Â 
Â  Â  else if (e.shiftKey && e.keyCode === 190) { // Shift + > (Redo)
Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  if (historyPointer < history.length - 1) {
Â  Â  Â  Â  Â  Â  historyPointer++;
Â  Â  Â  Â  Â  Â  restoreState();
Â  Â  Â  Â  }
Â  Â  }
}

function handleKeyup(e) {
Â  Â  if (e.key === 'Shift') {
Â  Â  Â  Â  isShiftPressed = false;
Â  Â  }
}
// =============================


function clearCanvas() {
Â  Â  context.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  context.fillStyle = BACKGROUND_COLOR;
Â  Â  context.fillRect(0, 0, canvas.width, canvas.height);
Â  Â  context.fillStyle = document.getElementById("colorPicker").value;Â 

Â  Â  saveState();Â 
}

function draw(curX, curY) {Â 
Â  Â  context.beginPath();
Â  Â  context.moveTo(startX, startY);
Â  Â  context.lineTo(curX, curY);
Â  Â  context.stroke();
}

// === [ë„í˜• ê·¸ë¦¬ê¸° ê´€ë ¨ í•¨ìˆ˜] ===

function drawShapePreview(curX, curY) {
Â  Â  restoreFromTempState();Â 
Â  Â  Â  Â Â 
Â  Â  context.save();Â 
Â  Â  context.strokeStyle = document.getElementById("colorPicker").value;Â 
Â  Â  context.lineWidth = penLineWidthRange.value;Â 
Â  Â  context.setLineDash([5, 5]);Â 
Â  Â Â 
Â  Â  const isRegular = isShiftPressed;

Â  Â  switch (currentTool) {
Â  Â  Â  Â  case 'rectangle':
Â  Â  Â  Â  Â  Â  drawRectangle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'circle':
Â  Â  Â  Â  Â  Â  drawCircle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'triangle':
Â  Â  Â  Â  Â  Â  drawTriangle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  }

Â  Â  context.restore();
}

function drawFinalShape(curX, curY) {
Â  Â  restoreState();Â 

Â  Â  context.setLineDash([]);Â 

Â  Â  context.strokeStyle = document.getElementById("colorPicker").value;Â 
Â  Â  context.lineWidth = penLineWidthRange.value;
Â  Â Â 
Â  Â  const isRegular = isShiftPressed;

Â  Â  switch (currentTool) {
Â  Â  Â  Â  case 'rectangle':
Â  Â  Â  Â  Â  Â  drawRectangle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'circle':
Â  Â  Â  Â  Â  Â  drawCircle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case 'triangle':
Â  Â  Â  Â  Â  Â  drawTriangle(startX, startY, curX, curY, isRegular);
Â  Â  Â  Â  Â  Â  break;
Â  Â  }
}

function drawRectangle(x1, y1, x2, y2, isRegular) {
Â  Â  let width = x2 - x1;
Â  Â  let height = y2 - y1;
Â  Â Â 
Â  Â  if (isRegular) {
Â  Â  Â  Â  const size = Math.min(Math.abs(width), Math.abs(height));
Â  Â  Â  Â  width = width > 0 ? size : -size;
Â  Â  Â  Â  height = height > 0 ? size : -size;
Â  Â  }
Â  Â Â 
Â  Â  context.beginPath();
Â  Â  context.strokeRect(x1, y1, width, height);Â 
}

function drawCircle(x1, y1, x2, y2, isRegular) {
Â  Â  const w = x2 - x1;
Â  Â  const h = y2 - y1;
Â  Â  const center_x = x1 + w / 2;
Â  Â  const center_y = y1 + h / 2;
Â  Â Â 
Â  Â  context.beginPath();

Â  Â  if (isRegular) {
Â  Â  Â  Â  // Shift + Drag: Perfect Circle (ì •ì›)
Â  Â  Â  Â  const radius_x = Math.abs(w / 2);
Â  Â  Â  Â  const radius_y = Math.abs(h / 2);
Â  Â  Â  Â  const radius = Math.min(radius_x, radius_y);
Â  Â  Â  Â Â 
Â  Â  Â  Â  context.arc(center_x, center_y, radius, 0, 2 * Math.PI);
Â  Â  } else {
Â  Â  Â  Â  // Simple Drag: Ellipse (íƒ€ì›)
Â  Â  Â  Â  const radius_x = Math.abs(w / 2);
Â  Â  Â  Â  const radius_y = Math.abs(h / 2);

Â  Â  Â  Â  // context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);
Â  Â  Â  Â  context.ellipse(center_x, center_y, radius_x, radius_y, 0, 0, 2 * Math.PI);
Â  Â  }
Â  Â Â 
Â  Â  context.stroke();
}

function drawTriangle(x1, y1, x2, y2, isRegular) {
Â  Â  let width = x2 - x1;
Â  Â  let height = y2 - y1;
Â  Â Â 
Â  Â  if (isRegular) {
Â  Â  Â  Â  const size = Math.min(Math.abs(width), Math.abs(height));
Â  Â  Â  Â  // ì •ì‚¼ê°í˜• ëŒ€ì‹  ì •ê·œ ì‚¬ê°í˜• ê¸°ë°˜ìœ¼ë¡œ ìˆ˜ì • (ì¼ë°˜ì ì¸ Shift+Drag ë™ì‘)
Â  Â  Â  Â  width = width > 0 ? size : -size;
Â  Â  Â  Â  height = height > 0 ? size : -size;
Â  Â  }
Â  Â Â 
Â  Â  const midX = x1 + width / 2;
Â  Â  const topX = midX;
Â  Â  const topY = y1;
Â  Â  const rightX = x1 + width;
Â  Â  const bottomY = y1 + height;
Â  Â  const leftX = x1;
Â  Â Â 
Â  Â  context.beginPath();
Â  Â  context.moveTo(topX, topY);Â  Â  Â  Â  Â 
Â  Â  context.lineTo(rightX, bottomY);Â  Â Â 
Â  Â  context.lineTo(leftX, bottomY);Â  Â  Â 
Â  Â  context.closePath();Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  context.stroke();
}
// ===================================

// === [í”ŒëŸ¬ë“œ í•„(Flood Fill) ê´€ë ¨ í•¨ìˆ˜] ===

// Hex ìƒ‰ìƒ ì½”ë“œë¥¼ [R, G, B, A] ë°°ì—´ë¡œ ë³€í™˜ (AëŠ” 255ë¡œ ê³ ì •)
function hexToRgbaArray(hex) {
Â  Â  const r = parseInt(hex.slice(1, 3), 16);
Â  Â  const g = parseInt(hex.slice(3, 5), 16);
Â  Â  const b = parseInt(hex.slice(5, 7), 16);
Â  Â  return [r, g, b, 255];Â 
}

// ë‘ RGBA ìƒ‰ìƒì´ ê°™ì€ì§€ ë¹„êµ
function colorsMatch(color1, color2) {
Â  Â  return color1[0] === color2[0] &&
Â  Â  Â  Â  Â  Â color1[1] === color2[1] &&
Â  Â  Â  Â  Â  Â color1[2] === color2[2] &&
Â  Â  Â  Â  Â  Â color1[3] === color2[3];
}

// í”½ì…€ì˜ RGBA ê°’ ê°€ì ¸ì˜¤ê¸°
function getPixelColor(imageData, x, y) {
Â  Â  const index = (y * imageData.width + x) * 4;
Â  Â  return [
Â  Â  Â  Â  imageData.data[index],
Â  Â  Â  Â  imageData.data[index + 1],
Â  Â  Â  Â  imageData.data[index + 2],
Â  Â  Â  Â  imageData.data[index + 3]
Â  Â  ];
}

// í”½ì…€ì˜ RGBA ê°’ ì„¤ì •
function setPixelColor(imageData, x, y, r, g, b, a) {
Â  Â  const index = (y * imageData.width + x) * 4;
Â  Â  imageData.data[index] = r;
Â  Â  imageData.data[index + 1] = g;
Â  Â  imageData.data[index + 2] = b;
Â  Â  imageData.data[index + 3] = a;
}


function floodFill(startX, startY) {
Â  Â  // 1. í˜„ì¬ ìº”ë²„ìŠ¤ í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
Â  Â  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
Â  Â  const width = imageData.width;
Â  Â  const height = imageData.height;
Â  Â Â 
Â  Â  // 2. í´ë¦­ëœ ì§€ì ì˜ ìƒ‰ìƒ (Target Color) ë° ì±„ìš¸ ìƒ‰ìƒ (Replacement Color) êµ¬í•˜ê¸°
Â  Â  const targetColor = getPixelColor(imageData, startX, startY);
Â  Â  const newColorHex = document.getElementById("colorPicker").value;
Â  Â  const newColor = hexToRgbaArray(newColorHex);

Â  Â  // 3. Target Colorì™€ New Colorê°€ ê°™ìœ¼ë©´ ì±„ìš°ê¸° ë¶ˆí•„ìš”
Â  Â  if (colorsMatch(targetColor, newColor)) {
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // 4. í ê¸°ë°˜ í”ŒëŸ¬ë“œ í•„ ì‹œì‘
Â  Â  const queue = [[startX, startY]]; // [x, y] ì¢Œí‘œ ìŒì„ ë‹´ëŠ” í
Â  Â Â 
Â  Â  while (queue.length > 0) {
Â  Â  Â  Â  const [x, y] = queue.shift();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ê²½ê³„ ë° ìƒ‰ìƒ ì¼ì¹˜ ì—¬ë¶€ í™•ì¸
Â  Â  Â  Â  if (x < 0 || x >= width || y < 0 || y >= height) continue;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const currentColor = getPixelColor(imageData, x, y);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (!colorsMatch(currentColor, targetColor)) continue;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // í”½ì…€ ìƒ‰ìƒ ë³€ê²½
Â  Â  Â  Â  setPixelColor(imageData, x, y, newColor[0], newColor[1], newColor[2], newColor[3]);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ì¸ì ‘ í”½ì…€ 4ë°©í–¥ íì— ì¶”ê°€
Â  Â  Â  Â  queue.push([x + 1, y]);
Â  Â  Â  Â  queue.push([x - 1, y]);
Â  Â  Â  Â  queue.push([x, y + 1]);
Â  Â  Â  Â  queue.push([x, y - 1]);
Â  Â  }
Â  Â Â 
Â  Â  // 5. ë³€ê²½ëœ í”½ì…€ ë°ì´í„°ë¥¼ ìº”ë²„ìŠ¤ì— ì ìš©
Â  Â  context.putImageData(imageData, 0, 0);
Â  Â Â 
Â  Â  // 6. ìƒíƒœ ì €ì¥
Â  Â  saveState();
}

// ===================================

// â­ ìŠ¤í¬ì´ë“œ (ìƒ‰ìƒ ì¶”ì¶œ) ê¸°ëŠ¥
function pickColor(x, y) {
Â  Â  const pixel = context.getImageData(x, y, 1, 1).data;
Â  Â  // RGBA í”½ì…€ ë°ì´í„°ë¥¼ Hex ì½”ë“œë¡œ ë³€í™˜
Â  Â  const hex = '#' + rgbToHex(pixel[0], pixel[1], pixel[2]);
Â  Â  
Â  Â  document.getElementById("colorPicker").value = hex;
Â  Â  setTool('pencil'); // ìƒ‰ìƒ ì„ íƒ í›„ íœ íˆ´ë¡œ ìë™ ì „í™˜
}


function down(e) {Â 
Â  Â  startX = e.offsetX; startY = e.offsetY;
Â  Â Â 
Â  Â  // Ctrl + ìš°í´ë¦­ (ì „ì²´ ì§€ìš°ê¸°)
Â  Â  if (e.ctrlKey && e.button === 2) {
Â  Â  Â  Â  clearCanvas();
Â  Â  Â  Â  drawing = false;
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  // ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­ (ê·¸ë¦¬ê¸°, ë„í˜• ë˜ëŠ” ì±„ìš°ê¸°)
Â  Â  if (e.button === 0) {
Â  Â  Â  Â Â 
Â  Â  Â  Â  // â­ ìŠ¤í¬ì´ë“œ íˆ´ ë¡œì§ ì¶”ê°€
Â  Â  Â  Â  if (currentTool === 'eyedropper') {
Â  Â  Â  Â  Â  Â  pickColor(startX, startY);
Â  Â  Â  Â  Â  Â  return; // íˆ´ì´ íœìœ¼ë¡œ ìë™ ì „í™˜ë˜ë¯€ë¡œ ì¶”ê°€ ì‘ì—… ë¶ˆí•„ìš”
Â  Â  Â  Â  }

Â  Â  Â  Â  // â­ ì±„ìš°ê¸° íˆ´ ë¡œì§
Â  Â  Â  Â  if (currentTool === 'fill') {
Â  Â  Â  Â  Â  Â  floodFill(startX, startY);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  // ë„í˜• ê·¸ë¦¬ê¸° ëª¨ë“œ
Â  Â  Â  Â  if (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'triangle') {
Â  Â  Â  Â  Â  Â  isDrawingShape = true;
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  // ì§ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ (Ctrl + ì¢Œí´ë¦­)
Â  Â  Â  Â  if (e.ctrlKey) {Â 
Â  Â  Â  Â  Â  Â  currentTool = 'line';Â 
Â  Â  Â  Â  Â  Â  drawing = false;
Â  Â  Â  Â  Â  Â  isErasing = false;
Â  Â  Â  Â  Â  Â  // íœ êµµê¸°/ìƒ‰ìƒ ì ìš©
Â  Â  Â  Â  Â  Â  updateContextStyles();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  context.beginPath();
Â  Â  Â  Â  Â  Â  context.arc(startX, startY, 2, 0, 2 * Math.PI);Â 
Â  Â  Â  Â  Â  Â  context.fill();Â 
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // íœ ê·¸ë¦¬ê¸° ëª¨ë“œ
Â  Â  Â  Â  drawing = true;
Â  Â  Â  Â  isErasing = false;
Â  Â  Â  Â  // íœ êµµê¸°/ìƒ‰ìƒ ì ìš©
Â  Â  Â  Â  updateContextStyles();

Â  Â  }Â 
Â  Â  // ë§ˆìš°ìŠ¤ ìš°í´ë¦­ (ì§€ìš°ê°œ)
Â  Â  else if (e.button === 2) {Â 
Â  Â  Â  Â  isErasing = true;
Â  Â  Â  Â  drawing = true;
Â  Â  Â  Â  currentTool = 'pencil';Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ì§€ìš°ê°œ êµµê¸°/ìƒ‰ìƒ ì ìš©
Â  Â  Â  Â  updateContextStyles();
Â  Â  }
}

function up(e) {Â 
Â  Â  let shouldSave = true;Â 
Â  Â Â 
Â  Â  // ì±„ìš°ê¸° íˆ´ì´ë‚˜ ìŠ¤í¬ì´ë“œ íˆ´ì€ downì—ì„œ ì´ë¯¸ ìƒíƒœë¥¼ ì €ì¥í–ˆê±°ë‚˜ ìƒíƒœ ì €ì¥ì´ ë¶ˆí•„ìš”í•˜ë¯€ë¡œ ê±´ë„ˆëœë‹ˆë‹¤.
Â  Â  if (currentTool === 'fill' || currentTool === 'eyedropper') {
Â  Â  Â  Â  shouldSave = false;
Â  Â  }
Â  Â  // ë„í˜• ê·¸ë¦¬ê¸° ì™„ë£Œ
Â  Â  else if (isDrawingShape) {
Â  Â  Â  Â  drawFinalShape(e.offsetX, e.offsetY);
Â  Â  Â  Â  isDrawingShape = false;
Â  Â  Â  Â  shouldSave = true;Â 
Â  Â  }
Â  Â  // ì§ì„  ê·¸ë¦¬ê¸° ì™„ë£Œ
Â  Â  else if (currentTool === 'line') {
Â  Â  Â  Â  draw(e.offsetX, e.offsetY);
Â  Â  Â  Â  currentTool = 'pencil';Â 
Â  Â  Â  Â  // UI íˆ´ë°” ìƒíƒœ ë³µê·€
Â  Â  Â  Â  document.getElementById('toolPencil').classList.add('active');
Â  Â  Â  Â  document.querySelectorAll('.tool-button').forEach(btn => {
Â  Â  Â  Â  Â  Â  if(btn.id !== 'toolPencil') btn.classList.remove('active');
Â  Â  Â  Â  });
Â  Â  }
Â  Â  else if (!drawing) {
Â  Â  Â  Â  shouldSave = false;Â 
Â  Â  }

Â  Â  drawing = false;Â 
Â  Â  isErasing = false;Â 
Â  Â Â 
Â  Â  // ë§ˆìš°ìŠ¤ ë²„íŠ¼ì„ ë†“ìœ¼ë©´ íœì˜ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ë³µì›
Â  Â  updateContextStyles();

Â  Â  if (shouldSave) {
Â  Â  Â  Â  saveState();Â 
Â  Â  }
}

function move(e) {
Â  Â  let curX = e.offsetX, curY = e.offsetY;
Â  Â Â 
Â  Â  // ë„í˜• ê·¸ë¦¬ê¸° ë¯¸ë¦¬ë³´ê¸°
Â  Â  if (isDrawingShape) {
Â  Â  Â  Â  drawShapePreview(curX, curY);
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  // ì—°ì† ê·¸ë¦¬ê¸° ë°©ì§€ íˆ´ (fill, eyedropper í¬í•¨)
Â  Â  if(currentTool === 'line' || currentTool === 'fill' || currentTool === 'eyedropper' || currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'triangle') return;
Â  Â Â 
Â  Â  if(!drawing) return;Â 
Â  Â Â 
Â  Â  // íœ ë˜ëŠ” ì§€ìš°ê°œ ì—°ì† ê·¸ë¦¬ê¸°
Â  Â  draw(curX, curY);Â Â 
Â  Â  startX = curX; startY = curY;
}

function out(e) {Â 
Â  Â  // ë„í˜• ê·¸ë¦¬ê¸° ì¤‘ ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì·¨ì†Œ
Â  Â  if (isDrawingShape) {
Â  Â  Â  Â  restoreState();Â 
Â  Â  Â  Â  isDrawingShape = false;
Â  Â  }
Â  Â Â 
Â  Â  if (drawing) {
Â  Â  Â  Â  saveState();
Â  Â  }
Â  Â  drawing = false;Â 
Â  Â  isErasing = false;Â 
Â  Â Â 
Â  Â  updateContextStyles();
}

function downloadCanvas() {
Â  Â  const imageURL = canvas.toDataURL("image/png");

Â  Â  const link = document.createElement('a');
Â  Â  link.download = 'ì˜¨ë¼ì¸_ê·¸ë¦¼íŒ_' + new Date().getTime() + '.png';
Â  Â  link.href = imageURL;
Â  Â Â 
Â  Â  document.body.appendChild(link);
Â  Â  link.click();
Â  Â Â 
Â  Â  document.body.removeChild(link);
}
function uploadCanvas() {
    // 1. ìº”ë²„ìŠ¤ ê·¸ë¦¼ ë°ì´í„°ë¥¼ Base64 í˜•ì‹ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.
    const imageBase64 = canvas.toDataURL("image/png");

    // 2. ê·¸ë¦¼ ë°ì´í„°ë¥¼ ë¸Œë¼ìš°ì €ì˜ ì„ì‹œ ì €ì¥ì†Œ(Local Storage)ì— ì €ì¥í•©ë‹ˆë‹¤.
    //    ì´ ë°ì´í„°ëŠ” ì»¤ë®¤ë‹ˆí‹° í˜ì´ì§€ì—ì„œ 'ì‘ì„±í•˜ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥¼ ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
    localStorage.setItem('currentDrawing', imageBase64);

    alert("ğŸ“¢ ê·¸ë¦¼ì´ ì„ì‹œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. ì»¤ë®¤ë‹ˆí‹° í˜ì´ì§€ì—ì„œ 'ê¸€ ì‘ì„±'ì„ ëˆŒëŸ¬ ê²Œì‹œí•˜ì„¸ìš”!");
    
    // 3. ì»¤ë®¤ë‹ˆí‹° í˜ì´ì§€ë¡œ ì´ë™
    goToCommunity(); 
}
   
function goToCommunity() {
    // ì„œë²„ë¥¼ í†µí•´ community.htmlë¡œ ì ‘ì†í•˜ë„ë¡ ê²½ë¡œ ìœ ì§€
    window.location.href = "./community.html";
}
</script>
</body>
</html>